"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.keygen = void 0;
const timegraph_wasm_1 = require("@analog-labs/timegraph-wasm");
class keygen {
    /**
     * Creates a new ```Keygen``` instance.
     * @param { IKeyringPair["sign"] | Signer["signRaw"] } args.signer the polkadot keyring keypair interface {@link https://www.npmjs.com/package/@polkadot/kering IKeyringPair["sign"]} keypair sign type is required for node
     * or the polkadot Signer interface {@link https://www.npmjs.com/package/@polkadot/extension-dapp Signer['signRaw']} injector signer interface is required for web.
     * @param {types.string} args.address the substrate wallet address used for authentication.
     * @returns {Keygen} a new keygen instance.
     *
     * Node usage Example
     *
     * ```
     * import Keyring from "@polkadot/keyring";
     * import { cryptoWaitReady } from "@polkadot/util-crypto";
     * import { Keygen } from "analog-js/timegraph-js";
     *
     * await cryptoWaitReady();
     * const keyring = new Keyring({ type: "sr25519" });
     * const keyparir = keyring.add...();
     * const _keygen = new Keygen({ signer: keypair.sign, address: keypair.address });
     * ```
     *
     * Web usage Example
     *
     * ```
     * import { web3FromSource, web3Enable, web3Accounts } from "@polkadot/extension-dapp";
     * import { keygen } from "@analog-labs/timegraph-js/keygen/web";
     *
     * await web3Enable();
     * const accounts = await web3Accounts();
     * await web3 = await web3FromSource();
     * const _keygen = new keygen({ signer: web3.signer.signRaw, address: accounts[0].address });
     *```
     */
    constructor({ signer, address }) {
        this._signer = signer;
        this._address = address;
    }
    /**
     * Creates a new ```GeneratedApiKey```.
     * @param {role} args.role the role for the user in timegraph i.e developer, collector, user
     * @param {env} args.env environment based on signer interface
     * @returns {Promise<GeneratedApiKey>} a new generated api key
     */
    createApiKey() {
        return __awaiter(this, arguments, void 0, function* (role = 'developer') {
            try {
                if (typeof window === 'undefined') {
                    return this.createNodeApiKey(role);
                }
                else {
                    return yield this.createWebApiKey(role);
                }
            }
            catch (e) {
                throw Error(`Error while creating Api Key ${e}`);
            }
        });
    }
    createNodeApiKey(role) {
        const [cert, secret] = (0, timegraph_wasm_1.new_cert)(this._address, role);
        const sign = this._signer;
        if (sign) {
            const signedData = sign(cert);
            const key = (0, timegraph_wasm_1.build_apikey)(secret, cert, signedData);
            return key;
        }
    }
    createWebApiKey(role) {
        return __awaiter(this, void 0, void 0, function* () {
            const { default: init } = yield Promise.resolve().then(() => __importStar(require('@analog-labs/timegraph-wasm/web/lib')));
            yield init();
            const [cert, secret] = (0, timegraph_wasm_1.new_cert)(this._address, role);
            const sign = this._signer;
            if (sign) {
                const signedData = yield sign({
                    address: this._address,
                    data: cert,
                    type: 'bytes',
                });
                const key = (0, timegraph_wasm_1.build_apikey)(secret, cert, this.hexToU8a(signedData.signature));
                return key;
            }
        });
    }
    /**
     * Creates a new ```GeneratedSessionKey```.
     * @param {expiration} args.expiration the expiration time in ms of the session key
     * @returns {Promise<GeneratedSessionKey>} a new generated session key
     */
    createSessionkey() {
        return __awaiter(this, arguments, void 0, function* (expiration = 0) {
            try {
                if (typeof window === 'undefined') {
                    return this.createNodeSSK(expiration);
                }
                else {
                    return yield this.createWebSSK(expiration);
                }
            }
            catch (e) {
                throw Error(`Error while creating Session Key ${e}`);
            }
        });
    }
    createNodeSSK(expiration) {
        const sign = this._signer;
        if (sign) {
            const ssk_data = (0, timegraph_wasm_1.encode_ssk)({
                ns: 0,
                key: this._address,
                user_id: 1,
                expiration: expiration,
            });
            const sskSignature = sign(this.stringToU8a(ssk_data));
            const ssk = (0, timegraph_wasm_1.build_ssk)(ssk_data, sskSignature);
            return { ssk };
        }
    }
    createWebSSK(expiration) {
        return __awaiter(this, void 0, void 0, function* () {
            const { default: init } = yield Promise.resolve().then(() => __importStar(require('@analog-labs/timegraph-wasm/web/lib')));
            yield init();
            const sign = this._signer;
            if (sign) {
                const ssk_data = (0, timegraph_wasm_1.encode_ssk)({
                    ns: 0,
                    key: this._address,
                    user_id: 1,
                    expiration: expiration,
                });
                const sskSignature = yield sign({
                    address: this._address,
                    data: ssk_data,
                    type: 'bytes',
                });
                const ssk = (0, timegraph_wasm_1.build_ssk)(ssk_data, this.hexToU8a(sskSignature.signature));
                return { ssk };
            }
        });
    }
    stringToU8a(inputString) {
        const u8a = new Uint8Array(inputString.length);
        for (let i = 0; i < inputString.length; i++) {
            u8a[i] = inputString.charCodeAt(i);
        }
        return u8a;
    }
    hexToU8a(hexString) {
        // Remove the "0x" prefix if present
        hexString = hexString.startsWith('0x') ? hexString.slice(2) : hexString;
        // Check if the input is a valid hexadecimal string
        if (!/^(0x)?[0-9A-Fa-f]*$/.test(hexString)) {
            throw new Error('Invalid hexadecimal string');
        }
        // Create a new Uint8Array from the hexadecimal string
        const u8a = new Uint8Array(hexString.length / 2);
        for (let i = 0; i < hexString.length; i += 2) {
            u8a[i / 2] = parseInt(hexString.slice(i, i + 2), 16);
        }
        return u8a;
    }
}
exports.keygen = keygen;
